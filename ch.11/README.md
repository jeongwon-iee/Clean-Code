# 🧷 11장 | 시스템

> 깨끗한 코드를 구현하면 낮은 추상화 수준에서 관심사를 분리하기 쉬워진다.  
높은 추상화 수준, 즉 시스템 수준에서도 깨끗함을 유지하는 방법을 살펴본다.

##

### 📘 시스템 제작과 시스템 사용을 분리하라

> SW 시스템은 애플리케이션 객체를 제작하고 의존성을 서로 '연결'하는 준비 과정과
준비 과정 이후에 이어지는 런타임 로직을 분리해야 한다.

- **제작(Construction): 어플리케이션 객체를 제작하고 의존성을 서로 연결하는 과정**  
- **사용(Use): 제작 과정 이후 이어지는 런타임 과정**

##

### 📘 관심사 분리

**가장 흔히 쓰이는 초기화 지연(Lazy Initialization)의 한계**

```java
public Service getService() {
  if (service == null)
    service = new MyServiceImpl(...);
  return service;
}
```

*장점*

- 실제로 필요할 때까지 객체를 생성하지 않으므로 불필요한 부하가 걸리지 않는다.  
→ 애플리케이션을 시작하는 시간이 그만큼 빨라진다.
- 어떤 경우에도 null 포인터를 반환하지 않는다.

*단점*

- `getService` 메서드가 `MyServiceImpl` 과 생성자 인수에 명시적으로 의존한다.
- `MyServiceImpl`이 무거운 객체라면 단위 테스트 시 적절한 **테스트 전용 객체**를 할당해야 한다.
- 일반 런타임 로직에 객체 생성 로직을 섞어놓은 탓에 모든 실행 경로(service가 null이 아닌 경로)도 테스트 해야 한다.
- 메서드가 작업을 두 가지 이상 수행한다 = 책임이 둘이다 → 단일 책임 원칙(SRP)을 깬다.
